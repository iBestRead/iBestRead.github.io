<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="将末端中间件转换为端点路由"><meta name="keywords" content=".NET CORE,.NET CORE 3.0,端点路由,Endpoint Routing"><meta name="author" content="Akini Xu"><meta name="copyright" content="Akini Xu"><title>将末端中间件转换为端点路由 | 嘉阅</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?90338b924a229bc3b13945771720922c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-157143555-1', 'auto');
ga('send', 'pageview');</script><link rel="dns-prefetch" href="http://ta.qq.com"><script>(function() {
   var hm = document.createElement("script");
   hm.src = "https://tajs.qq.com/stats?sId=66513060";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"58VSOBFQHT","apiKey":"055694feb7a00213dd437a9331d74cfb","indexName":"iBestReadBlog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#路由的演变"><span class="toc-number">1.</span> <span class="toc-text">路由的演变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在ASP-NET-Core-2-x中使用Map-时"><span class="toc-number">2.</span> <span class="toc-text">在ASP.NET Core 2.x中使用Map()时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#改中间件为端点路由"><span class="toc-number">3.</span> <span class="toc-text">改中间件为端点路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#必须把中间件改为端点路由吗"><span class="toc-number">4.</span> <span class="toc-text">必须把中间件改为端点路由吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.ibestread.com/img/akinix_logo.jpg"></div><div class="author-info__name text-center">Akini Xu</div><div class="author-info__description text-center">Best Read For You</div><div class="follow-button"><a href="https://github.com/akinix" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">25</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">37</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.ibestread.com/img/top_background.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">嘉阅</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">将末端中间件转换为端点路由</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-10</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 9 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>译者:  <a href="https://blog.ibestread.com">Akini Xu</a></p>
<p>原文:  <a href="https://andrewlock.net/converting-a-terminal-middleware-to-endpoint-routing-in-aspnetcore-3/" target="_blank" rel="noopener">Converting a terminal middleware to endpoint routing in ASP.NET Core 3.0</a></p>
<p>作者:  <a href="https://andrewlock.net/about/" target="_blank" rel="noopener">Andrew Lock</a></p>
</blockquote>
<p>此文是 <a href="/upgrading-to-asp-net-core-3">升级至 ASP.NET Core 3.0</a> 第4篇:</p>
<ol>
<li><a href="/converting-a-netstandard-2-library-to-netcore-3/">转换.NET Standard 2.0类库到.NET Core 3.0</a></li>
<li><a href="/ihostingenvironment-vs-ihost-environment-obsolete-types-in-net-core-3/">对比IHostingEnvironment与IHostEnvironment .NET及Core 3.0中的过时类型</a></li>
<li><a href="/avoiding-startup-service-injection-in-asp-net-core-3/">不要在Startup类的构造函数中使用依赖注入</a></li>
<li><a href="/converting-a-terminal-middleware-to-endpoint-routing-in-aspnetcore-3/">将末端中间件转换为端点路由</a></li>
<li><a href="/converting-integration-tests-to-net-core-3/">将集成测试升级至.NET Core 3.0</a></li>
</ol>
<p>在这篇文章中，主要介绍端点路由，并演示如何创建一个响应URL请求的端点。 并展示如何将ASP.NET Core 2.x中的末端中间件，升级为ASP.NET Core 3.0中的端点路由。</p>
<a id="more"></a>
<h2 id="路由的演变">路由的演变</h2>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.0" target="_blank" rel="noopener">ASP.NET Core中的路由</a>是将请求URL路径（例如/Orders/1）映射到响应的处理程序的过程。 它主要与MVC中间件一起使用，以将请求映射到<em>Controllers</em>和<em>Actions</em>。 还可以反向映射，根据指定参数生成URL。</p>
<p>在ASP.NET Core 2.1和更低版本中，通过实现<a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.routing.irouter" target="_blank" rel="noopener">IRouter接口</a>将请求的URL映射到处理程序来处理路由。 通常，不会直接实现这个接口来处理路由，而是在管道中添加<code>MvcMiddleware</code>实现。 一旦请求到达<code>MvcMiddleware</code>，路由会确定传入请求URL应该由哪个<em>Controller</em>的<em>Action</em>来执行。</p>
<p>另外，在执行<em>Action</em>前会经过了各种<a href="https://andrewlock.net/asp-net-core-in-action-filters/" target="_blank" rel="noopener">MVC过滤器</a>。 这些过滤器形成了另一条管道。在一些情况下，我们会重复一些中间件的行为。 一个典型的例子就是<a href="https://docs.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-2.2" target="_blank" rel="noopener">CORS政策</a>。 为了对不同的<em>MVC Action</em>配置不同的CORS策略，肯定会有些重复的代码。</p>
<p>中间件管道的“分支”通常用于“伪路由”。在中间件管道中使用<a href="https://github.com/aspnet/AspNetCore/blob/v2.1.12/src/Http/Http.Abstractions/src/Extensions/MapExtensions.cs" target="_blank" rel="noopener">Map()方法</a>，当请求的Url前缀满足条件时，执行指定的中间件。</p>
<p>例如，在<em>Startup.cs</em>中的<code>Configure()</code>方法对管道进行分支，当传入路径为<code>/ping</code>时，末端（很多会翻译为终端，我觉得终端有歧义）中间件将执行：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseStaticFiles();</span><br><span class="line">    app.UseCors();</span><br><span class="line">    app.Map(<span class="string">"/ping"</span>, </span><br><span class="line">        app2 =&gt; app2.Run(<span class="keyword">async</span> context =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"Pong"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    app.UseMvcWithDefaultRoute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，<code>Run()</code>方法是末端中间件，因为它直接返回响应。这个Map分支对应于应用程序来说，<code>app2</code>没有做其它事，就是一个末端。</p>
<p><img src="/images/loading.svg" data-original="https://cdn.ibestread.com/img/branching_middleware.svg" alt=""></p>
<p>与<code>MvcMiddleware</code>中的端点（<em>Controller</em>的<em>Action</em>）相比，该末端有点像是二等公民。 从传入路由中解析对象比较麻烦，您必须自己手动实现授权。</p>
<p>另一个问题是，例如，当请求到达<code>UseCors(</code>)中间件时，我们需要知道在哪个分支或末端上运行，<code>/ping</code>端点允许跨域请求，而MVC中间件则不允许 。</p>
<p>在ASP.NET Core 2.2中，Microsoft引入了<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.0" target="_blank" rel="noopener">端点路由</a>作为MVC控制器的新路由机制。 它的实现是在<code>MvcMiddleware</code>内部，还无法解决上述问题。 但是在ASP.NET Core 3.0中，它的范围有所扩展，成为了主要的路由机制。</p>
<p>新的端点路由将请求的路由与处理程序的实际执行分开。 这意味着您可以提前知道哪个处理程序将被执行。</p>
<p><img src="/images/loading.svg" data-original="https://cdn.ibestread.com/img/endpoint_routing.svg" alt=""></p>
<p>如何将之前的ping-pong管道映射到新的端点路由方式？</p>
<h2 id="在ASP-NET-Core-2-x中使用Map-时">在ASP.NET Core 2.x中使用Map()时</h2>
<p>我们来看一个<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/write?view=aspnetcore-2.2" target="_blank" rel="noopener">的自定义中间件</a>，它只<a href="https://andrewlock.net/version-vs-versionsuffix-vs-packageversion-what-do-they-all-mean/#fileversion" target="_blank" rel="noopener">返回应用程序的版本信息</a>，它是一个末端中间件，从代码中可以看到它没有再向后调用<code>_netx</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VersionMiddleware</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> RequestDelegate _next;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> Assembly _entryAssembly = System.Reflection.Assembly.GetEntryAssembly();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">string</span> _version = FileVersionInfo.GetVersionInfo(_entryAssembly.Location).FileVersion;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VersionMiddleware</span>(<span class="params">RequestDelegate next</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        context.Response.StatusCode = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(_version);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//we're all done, so don't invoke next middleware</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ASP.NET Core 2.x中，您可以在<em>Startup.cs</em>中通过使用<code>Map()</code>扩展方法来指定URL和对应的中间件：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseStaticFiles();</span><br><span class="line"></span><br><span class="line">    app.UseCors();</span><br><span class="line"></span><br><span class="line">    app.Map(<span class="string">"/version"</span>, versionApp =&gt; versionApp.UseMiddleware&lt;VersionMiddleware&gt;()); </span><br><span class="line"></span><br><span class="line">    app.UseMvcWithDefaultRoute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当您使用<code>/version</code>开头的URL（<code>/version</code>或<code>/version/test</code>）访问时，都获得相同的响应：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.0.0</span><br></pre></td></tr></table></figure>
<p>当您发送带有任何（除静态文件以外）的URL的请求时，将调用MvcMiddleware，并处理该请求。 使用上面的代码，CORS中间件无法知道哪个端点将最终被执行。</p>
<h2 id="改中间件为端点路由">改中间件为端点路由</h2>
<p>在ASP.NET Core 3.0中，我们使用端点路由，路由与端点的调用是分开的。 实际上，是有两个中间件：</p>
<ul>
<li><code>EndpointRoutingMiddleware</code> 称为路由中间件。根据请求的URL来计算由哪个端点来执行。</li>
<li><code>EndpointMiddleware</code>  成为端点中间件，调用中间件。</li>
</ul>
<p>它们分别添加在管道的两个不同的位置，起着两个不同的作用。 通常，您希望路由中间件更早的添加到管道中，以便后续的中间件可以获得端点（即将被执行地）的信息。 端点中间件应该在管道的最后。 例如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseStaticFiles();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the EndpointRoutingMiddleware</span></span><br><span class="line">    app.UseRouting();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All middleware from here onwards know which endpoint will be invoked</span></span><br><span class="line">    app.UseCors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the endpoint selected by the routing middleware</span></span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapDefaultControllerRoute();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展方法<code>UseRouting()</code>将<code>EndpointRoutingMiddleware</code>添加到管道，而扩展方法<code>UseEndpoints()</code>将<code>EndpointMiddleware</code>添加到管道。 通过使用<code>UseEndpoints()</code>会注册所有端点（在上面的示例中，我们仅注册我们的MVC控制器）。</p>
<blockquote>
<p>注意：通常将静态文件中间件放在路由中间件之前。 这样可以避免在请求静态文件时有额外的路由开销。 <a href="https://docs.microsoft.com/en-us/aspnet/core/migration/22-to-30?view=aspnetcore-3.0&amp;tabs=visual-studio#migrate-startupconfigure" target="_blank" rel="noopener">如迁移文档</a>中所述，将身份验证和授权<em>controllers</em> 放在两个中间件中间也很重要。</p>
</blockquote>
<p>下面我们使用新的端点路由方式改写之前的<code>VersionMiddleware</code>：</p>
<p>我们使用<code>/version</code> URL作为匹配路径，将注册版本端点的代码移到<code>UseEndpoints()</code>调用中：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseStaticFiles();</span><br><span class="line"></span><br><span class="line">    app.UseRouting();</span><br><span class="line"></span><br><span class="line">    app.UseCors();</span><br><span class="line"></span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add a new endpoint that uses the VersionMiddleware</span></span><br><span class="line">        endpoints.Map(<span class="string">"/version"</span>, endpoints.CreateApplicationBuilder()</span><br><span class="line">            .UseMiddleware&lt;VersionMiddleware&gt;()</span><br><span class="line">            .Build())</span><br><span class="line">            .WithDisplayName(<span class="string">"Version number"</span>);</span><br><span class="line"></span><br><span class="line">        endpoints.MapDefaultControllerRoute();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有几个重点我们需要注意：</p>
<ul>
<li>我们使用<code> IApplicationBuilder ()</code>来创建了<code>RequestDelegate</code>。</li>
<li>对路径的完整匹配，不再是前缀匹配方式。</li>
<li>可以对端点设置一个显示名称（上面代码中的&quot;Version number&quot;）</li>
<li>可以附加额外元数据（上面代码中没有展示）</li>
</ul>
<p><code>Map</code>方法需要<code>RequestDelegate</code>而不是<code>Action &lt;IApplicationBuilder&gt;</code>。导致添加中间件为端点的代码要比之前2.x更加冗长。 可以写一个扩展方法来解决这个问题：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">VersionEndpointRouteBuilderExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEndpointConventionBuilder <span class="title">MapVersion</span>(<span class="params"><span class="keyword">this</span> IEndpointRouteBuilder endpoints, <span class="keyword">string</span> pattern</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> pipeline = endpoints.CreateApplicationBuilder()</span><br><span class="line">            .UseMiddleware&lt;VersionMiddleware&gt;()</span><br><span class="line">            .Build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> endpoints.Map(pattern, pipeline).WithDisplayName(<span class="string">"Version number"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>Configure()</code>中使用这个扩展方法让代码更加简洁：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseStaticFiles();</span><br><span class="line"></span><br><span class="line">    app.UseRouting();</span><br><span class="line"></span><br><span class="line">    app.UseCors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the endpoint selected by the routing middleware</span></span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapVersion(<span class="string">"/version"</span>);</span><br><span class="line">        endpoints.MapDefaultControllerRoute();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一个重要差异是，在ASP.NET Core 2.x中，<code>VersionMiddleware</code>匹配<code>/version</code>为前缀的所有请求。 比如<code>/version</code>，<code>/version/123</code>，<code>/version/test/oops</code>等等。当改为使用端点路由时，并不是前缀匹配，而是完整匹配。 可以在端点路由中都使用路由参数。 例如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">endpoints.MapVersion(<span class="string">"/version/&#123;id:int?&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>这种写法可以匹配<code>/version</code>和<code>/version/123</code> URL，但不匹配<code>/version/test/oops</code>。</p>
<p>端点路由的另外一个特性，可以将元数据库附加到端点上。</p>
<p>端点的另一个功能是可以将元数据附加到端点。 在前面的示例中，我们提供了一个显示名称（主要用于调试目的），您还可以附加更多信息，例如授权策略或CORS策略，供其它中间件查询。 例如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseStaticFiles();</span><br><span class="line"></span><br><span class="line">    app.UseRouting();</span><br><span class="line"></span><br><span class="line">    app.UseCors();</span><br><span class="line">    app.UseAuthentication();</span><br><span class="line">    app.UseAuthorization();</span><br><span class="line"></span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapVersion(<span class="string">"/version"</span>)</span><br><span class="line">            .RequireCors(<span class="string">"AllowAllHosts"</span>)</span><br><span class="line">            .RequireAuthorization(<span class="string">"AdminOnly"</span>);</span><br><span class="line"></span><br><span class="line">        endpoints.MapDefaultControllerRoute();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，我们向<em>Version</em>端点中添加了CORS策略（<code>AllowAllHosts</code>）和授权策略（<code>AdminOnly</code>）。 当请求到达时，路由中间件选择<em>Version</em>端点，并附带了相关元数据， 当授权中间件和CORS中间件，发现<em>Version</em>端点存在这些策略时，会在<em>Version</em>端点执行前，先执行授权中间件和CORS中间件的逻辑。</p>
<h2 id="必须把中间件改为端点路由吗">必须把中间件改为端点路由吗</h2>
<p>不是必须的。中间件方式的管道概念并没有变。您仍然可以像ASP.NET Core 1.0以后的版本一样，完全从中间件分支或短路返回。不需要使用端点路由来替换原理的方法。</p>
<p>但是，使用端点路由有3个优势：</p>
<ul>
<li>可以将元数据附加到端点，以便其它中间件（例如Authorization，CORS）可以知道最终端点是谁，该执行什么操作</li>
<li>可以在非MVC的端点中使用路由模板，因此可以使用路由解析这个特性</li>
<li>可以更方便地生成指向非MVC端点的URL</li>
</ul>
<p>如果上述特性对您有用，那么端点路由非常适合您。 例如，<a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-3.0" target="_blank" rel="noopener">ASP.NET Core HealthCheck</a>已改为为端点路由，那么在请求健康状态Url时，添加授权检查。</p>
<p>如果您觉得这些特性没用，则没有理由不必转换为端点路由。 例如，静态文件中间件通常是短路响应的，没有将其转换为端点路由。 静态文件通常不需要将授权或CORS。</p>
<p>最重要的是，静态文件中间应将件放在路由中间件之前。</p>
<p>总体而言，端点路由在以前的路由方法中增加了许多特性，您需要在升级时注意差异。 如果尚未安装，请务必查看<a href="https://docs.microsoft.com/en-us/aspnet/core/migration/22-to-30" target="_blank" rel="noopener">迁移指南</a>，其中详细介绍了许多更改。</p>
<h2 id="总结">总结</h2>
<p>在这篇文章中，我概述了ASP.NET Core中的路由及其发展历程，及<strong>路由的请求</strong>与<strong>处理程序的执行</strong>分离后，带来的一些优势。</p>
<p>我还展示了，如何将ASP.NET Core 2.x应用程序中使用的简单末端中间件，转换为ASP.NET Core 3.0中的端点。 所需的更改相对较小，但需要注意的是<strong>支持路由参数的完整匹配</strong>替换了<strong>前缀匹配</strong>。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Akini Xu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.ibestread.com/converting-a-terminal-middleware-to-endpoint-routing-in-aspnetcore-3/">https://blog.ibestread.com/converting-a-terminal-middleware-to-endpoint-routing-in-aspnetcore-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.ibestread.com">嘉阅</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/NET-CORE/">.NET CORE</a><a class="post-meta__tags" href="/tags/NET-CORE-3-0/">.NET CORE 3.0</a><a class="post-meta__tags" href="/tags/%E7%AB%AF%E7%82%B9%E8%B7%AF%E7%94%B1/">端点路由</a><a class="post-meta__tags" href="/tags/Endpoint-Routing/">Endpoint Routing</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://cdn.ibestread.com/img/ali_pay_code.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://cdn.ibestread.com/img/tencent_pay_code.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e2ecc1ad505208a" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/converting-integration-tests-to-net-core-3/"><i class="fa fa-chevron-left">  </i><span>将集成测试升级至.NET Core 3.0</span></a></div><div class="next-post pull-right"><a href="/avoiding-startup-service-injection-in-asp-net-core-3/"><span>不要在Startup类的构造函数中使用依赖注入</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '627199878458c320fb74',
  clientSecret: '6e48bd6ac85dffc40aa34fa8cffd72b96517a294',
  repo: 'iBestRead.github.io',
  owner: 'iBestRead',
  admin: 'akinix',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://cdn.ibestread.com/img/top_background.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By Akini Xu</div><div class="footer_custom_text"><a href="http://www.beianbeian.com/beianxinxi/305c139fe2263063db72af4e473d63d7.html" target="_blank" rel="noopener">粤ICP备17015620号</a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>
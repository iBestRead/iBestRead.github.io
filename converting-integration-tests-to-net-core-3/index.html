<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="将集成测试升级至.NET Core 3.0"><meta name="keywords" content=".NET CORE,ASP.NET CORE,.NET CORE 3.0,Testing"><meta name="author" content="Akini Xu"><meta name="copyright" content="Akini Xu"><title>将集成测试升级至.NET Core 3.0 | 嘉阅</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?90338b924a229bc3b13945771720922c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-157143555-1', 'auto');
ga('send', 'pageview');</script><link rel="dns-prefetch" href="http://ta.qq.com"><script>(function() {
   var hm = document.createElement("script");
   hm.src = "https://tajs.qq.com/stats?sId=66513060";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"58VSOBFQHT","apiKey":"055694feb7a00213dd437a9331d74cfb","indexName":"iBestReadBlog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Test-Host和TestServer来做集成测试"><span class="toc-number">1.</span> <span class="toc-text">使用Test Host和TestServer来做集成测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NET-core-3-0中的TestServer"><span class="toc-number">2.</span> <span class="toc-text">.NET core 3.0中的TestServer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用WebApplicationFactory集成测试"><span class="toc-number">3.</span> <span class="toc-text">使用WebApplicationFactory集成测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在ASP-NET-Core-2-x中使用WebApplicationFactory添加XUnit日志"><span class="toc-number">4.</span> <span class="toc-text">在ASP.NET Core 2.x中使用WebApplicationFactory添加XUnit日志</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-number"></span> <span class="toc-text">标记中）。 应用程序生成的日志都通过管道传递到xUnit的输出，这使得易于理解集成测试失败时发生的原因：
[2019-10-29 18:33:23Z] info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
[2019-10-29 18:33:23Z] info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Development
...
[2019-10-29 18:33:23Z] info: Microsoft.AspNetCore.Routing.EndpointMiddleware[1]
      Executed endpoint &#39;&#x2F;Index&#39;
[2019-10-29 18:33:23Z] info: Microsoft.AspNetCore.Hosting.Diagnostics[2]
      Request finished in 182.4109ms 200 text&#x2F;html; charset&#x3D;utf-8

在ASP.NET Core 3.0中使用WebApplicationFactory
将集成测试项目转换为目标.NET Core 3.0之后，似乎不需要进行任何更改。 但是要注意，ExampleAppTestFixture的CreateWebHostBuilder()方法永远不会被调用。
原因是WebApplicationFactory需要同时支持Web主机和通用主机。 如果在Program.cs中使用了WebHostBuilder，则工厂将调用CreateWebHostBuilder()并运行重写的方法。 但是，如果使用的是通用HostBuilder，则工厂将调用另一种方法CreateHostBuilder()。
修改Factory的代码，将CreateWebHostBuilder重命名为CreateHostBuilder，将返回类型从IWebHostBuilder更改为IHostBuilder，然后将调用更改为使用通用主机。 其他所有内容保持不变：
public class ExampleAppTestFixture : WebApplicationFactory&lt;Program&gt;
&amp;#123;
    public ITestOutputHelper Output &amp;#123; get; set; &amp;#125;

    &#x2F;&#x2F; Uses the generic host
    protected override IHostBuilder CreatHostBuilder()
    &amp;#123;
        var builder &#x3D; base.CreateHostBuilder();
        builder.ConfigureLogging(logging &#x3D;&gt;
        &amp;#123;
            logging.ClearProviders(); &#x2F;&#x2F; Remove other loggers
            logging.AddXUnit(Output); &#x2F;&#x2F; Use the ITestOutputHelper instance
        &amp;#125;);

        return builder;
    &amp;#125;

    protected override void ConfigureWebHost(IWebHostBuilder builder)
    &amp;#123;
        builder.ConfigureTestServices((services) &#x3D;&gt;
        &amp;#123;
            services.RemoveAll(typeof(IHostedService));
        &amp;#125;);
    &amp;#125;
&amp;#125;


请注意，ConfigureWebHost方法不会更改-在两种情况下都会被调用，参数任然是IWebHostBuilder。

全部修改完成后，日志可以正常输出了。
总结
在这篇文章中，我描述了将应用程序从ASP.NET Core 2.1迁移到ASP.NET Core 3.0之后，集成测试中所需的一些更改。 仅且使用通用主机时，才需要进行这些更改。 如果要迁移到使用通用主机，则需要修改TestServer或WebApplicationFactory的代码。
修改TestServer代码，在HostBuilder.ConfigureWebHost()方法内调用UseTestServer()。 然后构建主机，并调用StartAsync()启动主机。 最后，调用IHost.GetTestClient()创建一个HttpClient。
修改自定义的WebApplicationFactory代码，如果使用WebHost，需要重写CreateWebHostBuilder方法。使用通用Host，需要重写CreateWebHostBuilder方法。
</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#在ASP-NET-Core-3-0中使用WebApplicationFactory"><span class="toc-number">1.</span> <span class="toc-text">在ASP.NET Core 3.0中使用WebApplicationFactory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">2.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.ibestread.com/img/akinix_logo.jpg"></div><div class="author-info__name text-center">Akini Xu</div><div class="author-info__description text-center">Best Read For You</div><div class="follow-button"><a href="https://github.com/akinix" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">19</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">34</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.ibestread.com/img/top_background.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">嘉阅</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">将集成测试升级至.NET Core 3.0</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-11</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 8 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>译者:  <a href="https://blog.ibestread.com">Akini Xu</a></p>
<p>原文:  <a href="https://andrewlock.net/converting-integration-tests-to-net-core-3/" target="_blank" rel="noopener">Converting integration tests to .NET Core 3.0</a></p>
<p>作者:  <a href="https://andrewlock.net/about/" target="_blank" rel="noopener">Andrew Lock</a></p>
</blockquote>
<p>此文是 <a href="/upgrading-to-asp-net-core-3">升级至 ASP.NET Core 3.0</a> 第5篇:</p>
<ol>
<li><a href="/converting-a-netstandard-2-library-to-netcore-3/">转换.NET Standard 2.0类库到.NET Core 3.0</a></li>
<li><a href="/ihostingenvironment-vs-ihost-environment-obsolete-types-in-net-core-3/">对比IHostingEnvironment与IHostEnvironment .NET及Core 3.0中的过时类型</a></li>
<li><a href="/avoiding-startup-service-injection-in-asp-net-core-3/">不要在Startup类的构造函数中使用依赖注入</a></li>
<li><a href="/converting-a-terminal-middleware-to-endpoint-routing-in-aspnetcore-3/">将末端中间件转换为端点路由</a></li>
<li><a href="/converting-integration-tests-to-net-core-3/">将集成测试升级至.NET Core 3.0</a></li>
</ol>
<p>在本文中，我们来讨论一下，当升级到ASP.NET Core 3.0后，集成测试代码中<code>WebApplicationFactory&lt;&gt;</code>或<code>TestServer</code>的变化。</p>
<p>ASP.NET Core 3.0的最大变化之一，是在通用主机架构上运行，而不是在WebHost上。 在本系列的前几篇文章及<a href="https://andrewlock.net/series/exploring-asp-net-core-3/" target="_blank" rel="noopener">探索ASP.NET Core 3.0的系列</a>中，我们已经解决了一部分升级后带来的问题，我们来看看对周边的基础设施有哪些影响，例如用于集成测试的<code>TestServer</code>。</p>
<a id="more"></a>
<h2 id="使用Test-Host和TestServer来做集成测试">使用Test Host和TestServer来做集成测试</h2>
<p>ASP.NET Core包含<em>Microsoft.AspNetCore.TestHost</em>库，它是一个可以在内存中运行的Web主机。</p>
<blockquote>
<p>这里面用了容易让人混淆的术语。内存中的主机和NuGet包通常被称为“ <strong>TestHost</strong>”，而在代码中使用的实际类是<strong>TestServer</strong>。 两者经常互换使用。</p>
</blockquote>
<p>在ASP.NET Core 2.x中，可以将<code>IWebHostBuilder</code>实例作为参数，传递给<code>TestServer</code>构造函数来创建测试服务器：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestHost2ExampleTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Fact</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ShouldReturnHelloWorld</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// Build your "app"</span></span><br><span class="line">        <span class="keyword">var</span> webHostBuilder = <span class="keyword">new</span> WebHostBuilder()</span><br><span class="line">            .Configure(app =&gt; app.Run(<span class="keyword">async</span> ctx =&gt; </span><br><span class="line">                    <span class="keyword">await</span> ctx.Response.WriteAsync(<span class="string">"Hello World!"</span>)</span><br><span class="line">            ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure the in-memory test server, and create an HttpClient for interacting with it</span></span><br><span class="line">        <span class="keyword">var</span> server = <span class="keyword">new</span> TestServer(webHostBuilder);</span><br><span class="line">        HttpClient client = server.CreateClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Send requests just as if you were going over the network</span></span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> client.GetAsync(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        response.EnsureSuccessStatusCode();</span><br><span class="line">        <span class="keyword">var</span> responseString = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">        Assert.Equal(<span class="string">"Hello World!"</span>, responseString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了一个简单的<code>WebHostBuilder</code>，针对所有的Url请求，都返回“ Hello World！”。 然后，使用<code>TestServer</code>创建一个内存服务器：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> TestServer(webHostBuilder);</span><br></pre></td></tr></table></figure>
<p>最后，我们创建一个<code>HttpClient</code>对象，发送HTTP请求发送到内存服务器。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client = server.CreateClient();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> client.GetAsync(<span class="string">"/"</span>);</span><br></pre></td></tr></table></figure>
<p>在.NET core 3.0中，写法还是类似的，但是由于迁移到通用主机，使用方法稍微复杂一些。</p>
<h2 id="NET-core-3-0中的TestServer">.NET core 3.0中的TestServer</h2>
<p>如果要升级.NET Core 2.x测试项目到.NET Core 3.0，编辑项目的*.csproj*，然后将<code>&lt;TargetFramework&gt;</code>元素更改为<code>netcoreapp3.0</code>。 接下来，将<em>Microsoft.AspNetCore.App</em>的<code>&lt;PackageReference&gt;</code>替换为<code>&lt;FrameworkReference&gt;</code>，并将其他软件包版本更新为<code>3.0.0</code>。</p>
<p>升级至.NET Core 3.0项目后，项目运行没有任何错误，并且可以通过测试。 但是，该代码中使用的是<code>WebHost</code>，而不是通用主机。 下面改为使用通用主机。</p>
<p>首先，使用HostBuilder替代WebHostBuilder：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hostBuilder = <span class="keyword">new</span> HostBuilder();</span><br></pre></td></tr></table></figure>
<p><code>HostBuilder</code>中没有<code>Configure()</code>方法。改成先调用<code>ConfigureWebHost()</code>，然后在内部<code>IWebHostBuilder</code>对象上调用<code>Configure()</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hostBuilder = <span class="keyword">new</span> HostBuilder()</span><br><span class="line">    .ConfigureWebHost(webHost =&gt; </span><br><span class="line">        webHost.Configure(app =&gt; app.Run(<span class="keyword">async</span> ctx =&gt;</span><br><span class="line">                <span class="keyword">await</span> ctx.Response.WriteAsync(<span class="string">"Hello World!"</span>)</span><br><span class="line">    )));</span><br></pre></td></tr></table></figure>
<p>改完后，<code>TestServer</code>构造函数这里编译报错。</p>
<p><img src="/images/loading.svg" data-original="https://cdn.ibestread.com/img/testserver.png" alt=""></p>
<p><a href="https://github.com/aspnet/AspNetCore/blob/master/src/Hosting/TestHost/src/TestServer.cs#L46" target="_blank" rel="noopener"><code>TestServer</code>构造函数参数类型是<code>IWebHostBuilder</code></a>，在通用主机中只有<code>IHostBuilder</code>。 我花了一些时间才发现根本不用手动创建<code>TestServer</code>：</p>
<ul>
<li>在<code>ConfigureWebHost</code>中调用<code>UseTestServer()</code>以添加<code>TestServer</code>实现。</li>
<li>在<code>IHostBuilder</code>上调用<code>StartAsync()</code>方法来构建和启动一个<code>IHost</code>实例。</li>
<li>在已启动的<code>IHost</code>实例上调用<code>GetTestClient()</code>获取<code>HttpClient</code>实例。</li>
</ul>
<p>最终的代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestHost3ExampleTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Fact</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ShouldReturnHelloWorld</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> hostBuilder = <span class="keyword">new</span> HostBuilder()</span><br><span class="line">            .ConfigureWebHost(webHost =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Add TestServer</span></span><br><span class="line">                webHost.UseTestServer();</span><br><span class="line">                webHost.Configure(app =&gt; app.Run(<span class="keyword">async</span> ctx =&gt; </span><br><span class="line">                    <span class="keyword">await</span> ctx.Response.WriteAsync(<span class="string">"Hello World!"</span>)));</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Build and start the IHost</span></span><br><span class="line">        <span class="keyword">var</span> host = <span class="keyword">await</span> hostBuilder.StartAsync();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create an HttpClient to send requests to the TestServer</span></span><br><span class="line">        <span class="keyword">var</span> client = host.GetTestClient();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> client.GetAsync(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        response.EnsureSuccessStatusCode();</span><br><span class="line">        <span class="keyword">var</span> responseString = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">        Assert.Equal(<span class="string">"Hello World!"</span>, responseString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有执行<code>UseTestServer()</code>，运行时会看到下面错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">System.InvalidOperationException : Unable to resolve service <span class="keyword">for</span> <span class="built_in">type</span> <span class="string">'Microsoft.AspNetCore.Hosting.Server.IServer'</span> <span class="keyword">while</span> attempting to activate <span class="string">'Microsoft.AspNetCore.Hosting.GenericWebHostService'</span></span><br></pre></td></tr></table></figure>
<h2 id="使用WebApplicationFactory集成测试">使用WebApplicationFactory集成测试</h2>
<p>像上面那样直接使用<code>TestServer</code>非常方便，但是对于实际项目的集成测试则不太方便。 <a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Testing" target="_blank" rel="noopener"><em>Microsoft.AspNetCore.Mvc.Testing</em></a>需要处理一些比较棘手问题，例如设置<em>ContentRoot</em>路径，将*.deps<em>文件复制到测试项目的</em>bin*文件夹等。使用<code>WebApplicationFactory&lt;&gt;</code>可以简化<code>TestServer</code>的创建过程。</p>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-3.0#customize-webapplicationfactory" target="_blank" rel="noopener">如何使用WebApplicationFactory&lt;&gt;的文档</a>，在.NET Core 3.0任然适用。 但是，ASP.NET Core 2.x升级到3.0时，还是需要一些调整。</p>
<h2 id="在ASP-NET-Core-2-x中使用WebApplicationFactory添加XUnit日志">在ASP.NET Core 2.x中使用WebApplicationFactory添加XUnit日志</h2>
<p>假设你的程序是按下面步骤设置的：</p>
<ul>
<li>通过<code>dotnet new webapp</code>创建的一个.NET Core Razor应用程序。</li>
<li>针对Razor应用程序项目创建了一个集成测试项目。</li>
</ul>
<p>这个演示项目的源码在<a href="https://github.com/andrewlock/blog-examples/tree/master/updating-test-host-to-3-0" target="_blank" rel="noopener">Github</a>中。</p>
<p>您可以按照<a href="https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-3.0#basic-tests-with-the-default-webapplicationfactory" target="_blank" rel="noopener">文档的说明</a>直接在测试中使用<code>WebApplicationFactory&lt;&gt;</code>类。 但有时候我们想自定义使用自定义的<code>WebApplicationFactory&lt;&gt;</code>，比如，<a href="https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-3.0#inject-mock-services" target="_blank" rel="noopener">替换一些Mock服务</a>、<a href="https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-3.0#customize-webapplicationfactory" target="_blank" rel="noopener">自动运行数据库迁移</a>、自定义<code>IHostBuilder</code>。</p>
<p>使用<a href="https://xunit.net/docs/capturing-output" target="_blank" rel="noopener">xUnit ITestOutputHelper</a>，将日志输出至<code>ILogger</code>中，方便查看<code>TestServer</code>中的错误信息。 <a href="https://twitter.com/martin_costello" target="_blank" rel="noopener">Martin Costello</a>提供的Nuget包<a href="https://www.nuget.org/packages/MartinCostello.Logging.XUnit/" target="_blank" rel="noopener"><em>MartinCostello.Logging.XUnit</em></a>比较方便做集成。代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">public class ExampleAppTestFixture : WebApplicationFactory&lt;Program&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Must be set in each test</span></span><br><span class="line">    <span class="keyword">public</span> ITestOutputHelper Output &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> IWebHostBuilder <span class="title">CreateWebHostBuilder</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">base</span>.CreateWebHostBuilder();</span><br><span class="line">        builder.ConfigureLogging(logging =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            logging.ClearProviders(); <span class="comment">// Remove other loggers</span></span><br><span class="line">            logging.AddXUnit(Output); <span class="comment">// Use the ITestOutputHelper instance</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ConfigureWebHost</span>(<span class="params">IWebHostBuilder builder</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// Don't run IHostedServices when running as a test</span></span><br><span class="line">        builder.ConfigureTestServices((services) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            services.RemoveAll(<span class="keyword">typeof</span>(IHostedService));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ExampleAppTestFixture</code>做了2件事：</p>
<ul>
<li>从容器中删除所有的<code>IHostedServices</code>（后台运行的服务），以便它们在集成测试期间不会运行。通常我们不希望，在测试时后台服务自动订阅或消费RabbitMQ/KafKa的消息。</li>
<li>使用<code>ITestOutputHelper</code>xUnit的日志与ASP.NET Core基础设施的<code>ILogger</code>挂接。</li>
</ul>
<p>要在测试中使用<code>ExampleAppTestFixture</code>，必须在测试类上实现<code>IClassFixture&lt;T&gt;</code>接口，将<code>ExampleAppTestFixture</code>通过构造函数注入，并设置Output属性。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">public class HttpTests: IClassFixture&lt;ExampleAppTestFixture&gt;, IDisposable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> ExampleAppTestFixture _fixture;</span><br><span class="line">    <span class="keyword">readonly</span> HttpClient _client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpTests</span>(<span class="params">ExampleAppTestFixture fixture, ITestOutputHelper output</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _fixture = fixture;</span><br><span class="line">        fixture.Output = output;</span><br><span class="line">        _client = fixture.CreateClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span> =&gt; _fixture.Output = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Fact</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">CanCallApi</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">await</span> _client.GetAsync(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        result.EnsureSuccessStatusCode();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> content = <span class="keyword">await</span> result.Content.ReadAsStringAsync();</span><br><span class="line">        Assert.Contains(<span class="string">"Welcome"</span>, content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例中请求RazorPages应用程序的主页，并在<em>body</em>中查找字符串“ Welcome”（位于<h1>标记中）。 应用程序生成的日志都通过管道传递到xUnit的输出，这使得易于理解集成测试失败时发生的原因：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2019-10-29 18:33:23Z] info: Microsoft.Hosting.Lifetime[0]</span><br><span class="line">      Application started. Press Ctrl+C to shut down.</span><br><span class="line">[2019-10-29 18:33:23Z] info: Microsoft.Hosting.Lifetime[0]</span><br><span class="line">      Hosting environment: Development</span><br><span class="line">...</span><br><span class="line">[2019-10-29 18:33:23Z] info: Microsoft.AspNetCore.Routing.EndpointMiddleware[1]</span><br><span class="line">      Executed endpoint <span class="string">'/Index'</span></span><br><span class="line">[2019-10-29 18:33:23Z] info: Microsoft.AspNetCore.Hosting.Diagnostics[2]</span><br><span class="line">      Request finished <span class="keyword">in</span> 182.4109ms 200 text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
<h2 id="在ASP-NET-Core-3-0中使用WebApplicationFactory">在ASP.NET Core 3.0中使用WebApplicationFactory</h2>
<p>将集成测试项目转换为目标.NET Core 3.0之后，似乎不需要进行任何更改。 但是要注意，<code>ExampleAppTestFixture</code>的<code>CreateWebHostBuilder()</code>方法永远不会被调用。</p>
<p>原因是<code>WebApplicationFactory</code>需要同时支持Web主机和通用主机。 如果在<em>Program.cs</em>中使用了<code>WebHostBuilder</code>，则工厂将调用<code>CreateWebHostBuilder()</code>并运行重写的方法。 但是，如果使用的是通用<code>HostBuilder</code>，则工厂将调用另一种方法<code>CreateHostBuilder()</code>。</p>
<p>修改<em>Factory</em>的代码，将<code>CreateWebHostBuilder</code>重命名为<code>CreateHostBuilder</code>，将返回类型从<code>IWebHostBuilder</code>更改为<code>IHostBuilder</code>，然后将调用更改为使用通用主机。 其他所有内容保持不变：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">public class ExampleAppTestFixture : WebApplicationFactory&lt;Program&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ITestOutputHelper Output &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Uses the generic host</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> IHostBuilder <span class="title">CreatHostBuilder</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">base</span>.CreateHostBuilder();</span><br><span class="line">        builder.ConfigureLogging(logging =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            logging.ClearProviders(); <span class="comment">// Remove other loggers</span></span><br><span class="line">            logging.AddXUnit(Output); <span class="comment">// Use the ITestOutputHelper instance</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ConfigureWebHost</span>(<span class="params">IWebHostBuilder builder</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        builder.ConfigureTestServices((services) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            services.RemoveAll(<span class="keyword">typeof</span>(IHostedService));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>请注意</strong>，<code>ConfigureWebHost</code>方法不会更改-在两种情况下都会被调用，参数任然是<code>IWebHostBuilder</code>。</p>
</blockquote>
<p>全部修改完成后，日志可以正常输出了。</p>
<h2 id="总结">总结</h2>
<p>在这篇文章中，我描述了将应用程序从ASP.NET Core 2.1迁移到ASP.NET Core 3.0之后，集成测试中所需的一些更改。 仅且使用通用主机时，才需要进行这些更改。 如果要迁移到使用通用主机，则需要修改<code>TestServer</code>或<code>WebApplicationFactory</code>的代码。</p>
<p>修改<code>TestServer</code>代码，在<code>HostBuilder.ConfigureWebHost()</code>方法内调用<code>UseTestServer()</code>。 然后构建主机，并调用<code>StartAsync()</code>启动主机。 最后，调用<code>IHost.GetTestClient()</code>创建一个<code>HttpClient</code>。</p>
<p>修改自定义的<code>WebApplicationFactory</code>代码，如果使用<code>WebHost</code>，需要重写<code>CreateWebHostBuilder</code>方法。使用通用<code>Host</code>，需要重写CreateWebHostBuilder方法。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Akini Xu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.ibestread.com/converting-integration-tests-to-net-core-3/">https://blog.ibestread.com/converting-integration-tests-to-net-core-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.ibestread.com">嘉阅</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/NET-CORE/">.NET CORE</a><a class="post-meta__tags" href="/tags/ASP-NET-CORE/">ASP.NET CORE</a><a class="post-meta__tags" href="/tags/NET-CORE-3-0/">.NET CORE 3.0</a><a class="post-meta__tags" href="/tags/Testing/">Testing</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://cdn.ibestread.com/img/ali_pay_code.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://cdn.ibestread.com/img/tencent_pay_code.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e2ecc1ad505208a" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/awesome-windows-applications/"><i class="fa fa-chevron-left">  </i><span>Windows上优质精选的最佳应用程序及工具列表</span></a></div><div class="next-post pull-right"><a href="/converting-a-terminal-middleware-to-endpoint-routing-in-aspnetcore-3/"><span>将末端中间件转换为端点路由</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '627199878458c320fb74',
  clientSecret: '6e48bd6ac85dffc40aa34fa8cffd72b96517a294',
  repo: 'iBestRead.github.io',
  owner: 'iBestRead',
  admin: 'akinix',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://cdn.ibestread.com/img/top_background.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By Akini Xu</div><div class="footer_custom_text"><a href="http://www.beianbeian.com/beianxinxi/305c139fe2263063db72af4e473d63d7.html" target="_blank" rel="noopener">粤ICP备17015620号</a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>